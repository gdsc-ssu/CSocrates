# B-Tree
- 균형트리로 이진 탐색 트리의 불균형이 되는 문제를 해결하기 위해 도입됨
- n개의 키가 하나의 노드에 존재하고, 노드가 최대 n+1개의 자식을 가질 수 있는 구조로 설계됨
- 주로 데이터베이스의 인덱스를 처리하기에 용이함 (처음부터 인덱스를 처리하기 용이하게 만든 것)
- 균형이 무너지는 경우 루트부터 리밸런싱을 시도
# B+ Tree
- B-Tree와 비슷하지만 리프노드를 모두 Linked-list로 연결해놓음
- non-리프노드는 데이터를 저장하는 것이 아닌, 데이터의 경로만 저장하게 함으로 빠르게 탐색이 가능
- 대신 B-Tree보다 용량이 더 커지게 되고, 실제 데이터를 확인하기 위해서는 항상 Leaf 노드까지 내려가야함
# B* Tree
- B-Tree의 단점인 구조를 유지하기 위해 추가적인 연산 혹은 새로운 노드 생성이 되어야 한다.
- 그래서 노드의 전체 용량을 2/3로 늘렸다 (기존 1/2) 또한 즉시 분할 대신 최대한 자식을 늘려서 유지할 때의 연산을 줄이도록 한다.

# Disjoint Set
- 공통 원소를 갖는 여러 개의 집함을 효율적으로 관리하는 방법
- 두 원소가 같은 집합에 속하는지 판별하거나, 두 집합을 하나로 합치는 연산을 빠르게 작업 가능
# Kruscal / MST
- Kruscal
	- MST를 찾는 알고리즘
	- 그래프 내 모든 정점을 가장 적은 비용으로 연결하고, 사이클이 없는 상태로 만든다.
- MST (Minimum Spanning Tree)
	- 그래프의 모든 정점을 최소 비용으로 연결하는 부분 그래프
	- 트리의 성질에 따라서 정점 수가 N개 일 때, N-1개의 간선을 가진다.
# AVL
- Adelson-Velskii Landis Tree
- 오른쪽 자식의 트리 높이 차이가 최대 1이 되도록 유지하여 균형을 맞춤
- 임의의 노드 X에 대해서 왼쪽 / 오른쪽 서브 트리의 높이 차이가 1 이하여야 한다.
	- 만약 만족하지 못하는 경우 재배치
# Red-Black Tree
- 자가 균형 이진 트리의 종류
- 레드-블랙 트리의 성질
	1. 모든 노드는 red 혹은 black이다.
	2. 루트 노드는 black이다.
	3. nil 노드가 존재한다.
		1. 자녀가 없을 때 nil노드로 연결됨
		2. 값이 있는 노드와 동등하게 취급
		3. 모든 nil 노드는 black
	4. red의 자식은 무조건 black이다.
		1. red는 연속적으로 존재할 수 없다.
	5. 임의의 노드에서 자손 nil 노드까지 경로에 존재하는 black의 수는 같다.
		1. 자신을 제외한 black의 개수
# Tree
- 사이클이 없는 그래프
- 계층을 나타내는 경우 대부분 트리 자료구조를 사용한다.
- 만약 완전 이진 트리를 만족하는 경우 배열을 활용할 수 있고, 아니라면 LinkedList로 표현할 수 있다.
# Trie
- 문자열 검색에 특화된 자료구조
- 트리구조를 순회하며, 포인터 인덱스가 해당 문자을 의미한다.
- "abc"라는 문자를 저장할 때는, 루트->nxt[0]->nxt[1]->nxt[2]에 isTerminal 값을 true로 해준다.
- 특정 문자가 들어있는지 판단하기 굉장히 쉽다.
# Heap
- 부모가 제일 크면 MaxHeap / 제일 작으면 MinHeap
# 후기
- 스터디는 이전에 하고 후기를 나중에 적으니까 이때는 기억이 났는데 다시 정리하면서 보니 이해하기 어려운 부분이 많았다. (AVL, Red-Black Tree)
- 바로바로 적으면서 정리하는 습관을 들여야겠다.
- 자료구조의 각 핵심마다 해결하고자하는 것들이 존재하고, 이미 이것들을 활용해서 우리 주변에서 문제들을 해결하고 있다는 것을 알 수 있었다.