### 출처

* [어째서 인덱스는 B트리일까](https://helloinyong.tistory.com/296)
* [비트리 애니메이션](https://hudi.blog/db-index-and-indexing-algorithms/)
* [B-tree 복잡도](https://cs.stackexchange.com/questions/59453/why-is-b-tree-search-olog-n)
___
### 개요
* [[#B-tree란]]
* [[#B-tree의 기원]]
* [[#인덱스엔 B-tree]]
* [[#B-tree의 정의]]
* [[#왜 B-tree의 탐색은 O(logN)이에요?]]
* [[#B-tree의 연산]]
___
### B-tree란

비 트리는 균형 트리의 일종으로 이진 탐색 트리의 불균형 문제를 해결하고자 도입된 자료구조이다.
비 트리는 **이진탐색 트리와 달리 n개의 키가 한 노드에 존재하고 이 노드가 최대 n+1개의 자식을 가질 수 있는 구조로 설계**돼 있다.

이렇게 한 노드에 저장할 수 있는 자식의 수를 늘림으로써 비 트리는 트리의 크기를 단축하고 검색 속도를 향상 시키는 특징을 갖게 됐다.

> [!info]
> B-tree는 균형트리로 <b><u>노드가 보유할 수 있는 자식 수를 증가시켜 트리의 높이를 낮추는 자료구조이다.</u></b>

___
### B-tree의 기원

![[Pasted image 20240308145729.png]]

<b><u>비 트리의 탄생 배경은 디스크 탐색에 있다.</u></b> 디스크에 데이터를 저장하면 데이터는 특정 트랙, 특정 섹터에 저장된다. 이때 데이터가 저장되는 구역을 데이터 블록이라 하고 각각의 블록 안에 실질적인 데이터가 저장되게 된다. 

따라서 우리가 실질적인 데이터 탐색을 하기 위해선 블럭 내부를 탐색할 필요가 존재하는데, 블럭 내부를 전수 조사하겠다는 의미는 곧 섹터를 전부 탐색하는 것과 마찬가지 행위이다.
 
이를 위해 인덱스가 존재한다. **인덱스는 목차와 같은 역할로 여러 블럭을 묶어 효율적인 데이터 탐색을 하게 해준다.** 인덱스는 기존 데이터 배열과 분리되 별개의 형태로 존재하는데 이 각각의 인덱스가 포인터 역할을 해 블럭을 전부 순회할 필요 없이 인덱스를 통한 접근이 가능해진다.

![[Pasted image 20240308150410.png]]


이에 따라서 곧 ==**데이터 블럭을 탐색하는 행위는 해당 데이터 블럭이 위치한 인덱스를 파악하는 행위가 됐고 이 인덱스를 관리하는데 있어 B-tree는 무엇보다도 효율적인 형태**==였다.

>[!info]
>**B-tree는 인덱스 형태의 데이터 탐색에 최적화된 자료구조로 만들어졌다.**

생각해보면 탐색 속도 개선이 목표라면 B-tree말고도 AVL 트리나, 레드블랙 트리 혹은 배열이나 해시 맵 같은 대안을 활용해 볼 수도 있다. 그런데 왜 B-tree였을까?
___
### 인덱스엔 B-tree

우리는 비 트리가 인덱스 형태의 데이터 탐색에 유리하다는 특성을 알게됐고 이로 인해 디스크의 인덱스 관리에서 활용된다는 점을 학습했다. 하지만 여전히 풀리지 않는 의문은 비 트리가 다른 자료구조에 비해 특별히 인덱스 탐색에 있어 더욱 유리한 부분을 특정할 수 없다는 것이다.

#### 해시맵을 써보면 어떨까?
해시맵을 활용하면 단일 값을 탐색하는데 있어선 가장 빠른 속도를 보여준다. 각 데이터의 위치를 메모리 상에서 자장하고 있어야 하는 것은 비트리도 마찬가지 이므로 메모리 오버헤드도 그렇게까지 발생할 것으로 보이지는 않는다.

하지만 ==해시 맵이 갖는 가장 큰 단점은 부등호에 약하다==는 것이다. 아래와 같은 어떠한 범위의 데이터가 결과로 반환되는 쿼리를 실행한다고 했을 때를 가정해보면 **해시 맵은 정렬 돼 있지 않으므로 탐색에 비효율적이 발생한다. 따라서 = 연산만 있는 경우라면 해시맵이 적합할 수 있으나 <> 가 쿼리에 사용되는 순간 해시 맵은 이점을 잃게 된다.** 
```sql
SELECT index FROM DISK WHERE index > 20 AND index < 100;
```

#### 레드블랙 트리는 어떨까?
같은 균형 트리인 레드블랙 트리를 사용해 보는 것도 나쁘지 않은 생각이다. 하지만 레드블랙 트리는 비 트리에 비해 노드가 가질 수 있는 데이터의 수가 1개라는 단점이 존재한다. 이 특징으로 인해 레드 블랙 트리는 비 트리에 비해 높이가 더 높아지는 특징을 갖게된다.

**비 트리 또한 한 노드 내에서 탐색을 진행해야 한다는 오버헤드가 존재하지만 배열 참조와 포인터 접근은 시간 차이가 극명하게 발생하는 접근 방식**이다. 따라서 아래로 깊어지는 레드 블랙 트리를 활용하기 보단 옆으로 퍼지는 비 트리를 활용하는 것이 더욱 효율적이다.

#### 배열, 링크드 리스트를 쓴다면?
배열을 쓴다면 탐색 속도는 가장 빠르게 처리할 수 있겠지만, 탐색 외의 모든 과정에서 심각한 오버헤드가 발생하게 된다. 링크드리스트 또한 삭제, 추가 과정에선 큰 문제가 없겠지만, 탐색에서 심각한 오버헤드가 발생하게 된다.

#### 그래서 인덱스는 B-tree를 쓰는 것이 좋다
이러한 이유로 ==**인덱스를 구현할 때 대다수의 DB 엔진이 비 트리를 채택해 사용하고 있다.**== 이유를 정리하자면 다음과 같다.
1. **B-tree는 한 노드에 여러 데이터를 포함할 수 있고 이는 정렬돼 있다. 이에 따라 부등호 연산에 강하다. (범위 탐색에 유리)**
2. **참조 포인터와 배열을 적절히 융합해 메모리 접근 속도가 빠른 편이다 (레드 블랙 트리보다 높이가 낮음)**
3. **데이터의 탐색 뿐만 아니라 추가, 삭제가 발생하는 경우에도 최대 O(logN)의 복잡도를 갖는다.**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd78iJ0%2FbtqKRYbLdM9%2FnIvz1M4gffMl4YHS77JSfK%2Fimg.png)
___
### B-tree의 정의

![[스크린샷 2024-03-08 오후 4.39.34.png]]
1. **모든 노드안의 데이터는 오름차 순으로 정렬돼 있다.**
2. **리프노드가 아닐 경우 각 노드는 자신의 데이터 수 + 1 만큼의 자식을 갖고 있어야 한다.**
3. 자식은 각각 다른 범위를 갖는데 범위는 다음과 같이 설정된다.
	* 부모 노드의 데이터 x1, x2가 존재할 때 자식 c1, c2, c3는 각각 다음의 범위를 갖는다.
		* c1 < x1 
		* x1 <= c2 <= x2
		* x2 < c3
4. ==**모든 리프 노드는 동일한 깊이를 가져야 한다.**==
5. 차수를 t라고 할때 루트를 제외한 **각 노드는 최소 t  - 1 만큼의 데이터를 가져야 한다**. 
	* **모든 노드는 최대 2t - 1만큼의 데이터를 가질 수 있다.** 따라서 최대 자식 수는 2t이다.

____
### 왜 B-tree의 탐색은 O(logN)이에요?

비 트리의 탐색은 이진 탐색트리와 흡사하게 진행된다. 비 트리 역시 데이터의 크기에 따라 저장할 노드의 위치가 구분 되므로 데이터의 값에 알맞게 노드를 내려가며 탐색을 진행한다.

아래의 이미지를 보면 직관적으로 이해가 된다. 아래는 28을 탐색하는 알고리즘이다.

![[b-tree-search-008af18fe34f881eed12cc302d49daf2.gif|https://hudi.blog/db-index-and-indexing-algorithms/]]
직관적으로 뭔가 O(logN)의 복잡도를 가질 것 같지만 설명하자면 뭔가 난해하다. 하나하나 짚고 넘어가보자. 우선적으로 비 트리의 높이에 대해 생각해보자. **차수를 m이라고 한다면, 최대 m - 1 개의 데이터를 가질 수 있으므로 각 노드는 최대 m개의 자식을 가질 수 있다.**

이에 따라 **트리의 높이가 높아질 때마다 트리에 저장할 수 있는 데이터의 수는 m의 제곱으로 증가**하게 된다. 따라서 **최적의 경우를 고려할 경우 트리에는 최대 m^h(트리의 높이) 만큼의 데이터를 가질 수 있게 된다.**

이에 따라 트리에 데이터가 N개 존재한다고 가정하면 해당 노드까지의 탐색은 최적의 경우 O(logN)(밑은 m이다)으로 가능하다. 하지만 이는 데이터가 존재할 것으로 추정되는 노드에 도달하는데 소요되는 시간일 뿐 **실제 데이터 탐색을 위해서는 해당 노드 내부에서 어느 가지로 내려 갈 것인지를 결정하기 위한 O(m)의 연산이 추가적으로 요구된다.**  이때 노드 내부의 데이터는 정렬돼 있으므로 이진 탐색을 활용할 수 있다. 따라서 **어느 가지로 내려갈 것인지를 탐색하는 시간은 O(logm)의 복잡도로 처리 가능하다.**

따라서 **B-tree의 탐색에 소요되는 시간은 최적의 경우 노드 내부에서 경로를 탐색하는 시간 O(logm * logN)이 된다.**  반대로 **최악의 경우는 각 노드에 데이터가 전부 최저한으로 존재해 트리의 깊이가 최대가 되는 O(logm * log(2/N -1 )) 이 된다.**
____
### B-tree의 연산

#### Search
```python
def search(node, key):
    # 노드가 None이면 탐색 실패
    if node is None:
        return None

    # 현재 노드에서 키를 찾음
    for i in range(len(node.keys)): #이진 탐색을 하면 더 좋아져용
        # 키를 찾으면 해당 인덱스를 반환
        if key == node.keys[i]:
            return node, i

        # 키가 현재 노드의 키보다 작으면 왼쪽 자식으로 이동
        elif key < node.keys[i]:
            return search(node.children[i], key)

    # 키가 현재 노드의 키보다 크면 오른쪽 자식으로 이동
    return search(node.children[len(node.keys)], key)

```

이진 탐색 트리와 달리 2가지의 경우만 존재하는 것이 아니라 데이터의 수 + 1 만큼의 경우로 이동할 수 있다.

#### Insert
비 트리의 삽입의 핵심은 균형이 무너지는 경우 **루트까지 트리의 리밸런싱을 진행하며 전체 트리의 높이를 1씩 증가시키는 방법으로 대응한다는 것이다.**

![[ezgif.com-video-to-gif-converter.gif]]

원**론적인 비 트리의 삽입 알고리즘은 바텀 업 방식으로 동작**한다. 아래의 이미지를 보자.

![[Pasted image 20240309002359.png]]
![[Pasted image 20240309002413.png]]
![[Pasted image 20240309002432.png]]
작업의 진행 순서를 확인해보면 우선적으로 리프 노드까지 이동한 후 리프 노드에서 분할이 요구되면 거꾸로 흐름을 거슬러 올라가며 분할이 진행되는 것을 확인할 수 있다. 하지만 아래 코드를 살펴보면 다른 형태로 구현한 것을 확인할 수 있다.

```python
def insert(self, k):
	if not self.root:
		self.root = BTreeNode(self.t)
		self.root.keys.append(k)
	else:
		if len(self.root.keys) == (2 * self.t) - 1: #루트를 쪼개야 할 경우
			new_root = BTreeNode(self.t, leaf=False)
			new_root.children.append(self.root)
			self.root = new_root
			self.split_child(self.root, 0)
		self._insert_non_full(self.root, k)

def _insert_non_full(self, node, k):
	i = len(node.keys) - 1
	if node.leaf:
		node.keys.append(None) #key가 비어있는 경우 처리
		while i >= 0 and k < node.keys[i]: #이진 탐색을 하면 더 좋아요
			node.keys[i+1] = node.keys[i] #배열 정렬 
			i -= 1
		node.keys[i+1] = k #배열의 제자리에 할당
	else:
		while i >= 0 and k < node.keys[i]:
			i -= 1
		i += 1 #-1까지 탐색하므로
		if len(node.children[i].keys) == (2 * self.t) - 1: #만약 노드가 full이면 쪼개준다.
			self.split_child(node, i) #노드를 쪼갠다.
			if k > node.keys[i]:
				i += 1
		self._insert_non_full(node.children[i], k) #트리를 내려가며 반복

```

코드를 살펴보면 바텀 업이 아닌 탑 다운 방식으로 루트부터 크기가 전부 매워진 노드를 마주칠 때 마다 전부 분할을 진행하며 리프노드로 향하는데 알고리즘을 이렇게 작성한데는 이유가 존재한다.

* **바텀 업 방식에 비해 한번의 트리 순회로 삽입을 보장할 수 있다.**
	* 바텀 업 방식의 경우 리프 노드에서 분할의 필요성을 파악할 경우 트리를 다시금 거꾸로 순회해야 한다는 문제가 존재한다.

물론 이 경우 **리프노드가 비어있었다면 필요 없는 분할을 진행해 낭비**가 되지만, 비 트리가 저장하는 것이 디스크의 인덱스이고 이들이 노드의 형태로 표현되는 것이기 때문에  비 트리에서 각 노드의 참조가 디스크 IO 연산과 동일하다 생각하면 노드를 여러번 참조하는 것 보다, 연산 횟수는 늘더라도 참조횟수를 줄이는 것이 이상적이긴 하다. 

>[!info]
>IO 여러번 보다 연산 여러 번이 효율적이라는 생각에 대다수의 B-tree 삽입 알고리즘은 이러한 형태로 구현된다.

___
### Delete
삭제는 작가님 개인 사정으로 3.16에 업로드 예정입니다.
___
### 요약

* 비 트리는 균형 트리로 2개 이상의 데이터와 자식을 보유할 수 있는 트리이다.
* 비 트리는 디스크의 저장 공간을 효율적으로 관리하는 인덱스를 저장하는데 최적화 된 구조이다.
	* 이는 삽입, 삭제, 탐색이 용이하고 범위 검색이 간편하기 때문이다.
* 비 트리의 핵심 아이디어는 노드에 최대한 많은 데이터를 저장 시켜 높이를 줄이는 것이다.
* 높이 유지를 위한 분할 알고리즘은 리소스가 많이 들지만, 트리를 순회하는 것 보다는 효율적이다.

