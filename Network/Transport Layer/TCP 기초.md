#tcp

### 출처
https://evan-moon.github.io/2019/11/10/header-of-tcp/ (정리 정말 잘됨)
https://docs.likejazz.com/close-wait/ (Close-wait 트러블 슈팅)
___
### 개요
* **TCP의 기본 개념을 이해한다**
* **TCP의 탄생 원인과 목적을 파악한다**
* **TCP의 특성을 이해한다
* **핸드 쉐이크의 개념을 이해한다
* **Half-close, Half-open을 이해한다
___
### TCP란

<u>TCP는 전송 계층에서 사용하는 프로토콜로 데이터 전송에 신뢰성을 보장한다.</u> TCP는 흐름제어, 연결 제어 등을 통해 이를 보장하며, 이로 인해 TCP 위에 위치한 프로그램들은 데이터의 완벽 전송을 보장 받을 수 있다.
TCP의 핵심은 신뢰성있는 통신 즉 손실 없는 통신이며, 나머지 요소는 해당 속성을 구현하기 위해 필요한 요소들이다.
___
### TCP는 왜 만들었을까?
옛날 옛적에는 패킷을 통한 부분 전송이라는 개념이 존재하지 않았다. 무조건 **==회선대 회선으로 통신을 진행하면서 전화 교화원이 연결을 바꿔주는 방식으로 통신이 진행됐다**.== 따라서 우리집에서 철수네 집까지 전화를 연결하려면 <u>우리집 - 중계소 - 중계소 2 - 철수네 집</u>까지 연결되는 회선을 한개 이상씩은 사용해야만 했다.
이러한 방식은 크게 2가지의 문제가 존재했는데, 첫번째는 무조건 하나의 회선을 독점해야 하므로 많은 사용자가 몰릴 경우 이용이 어렵다는 점이고 두번째는 내가 사용하고 있던 회선이나 중계국이 박살 날 경우 연결이 중단된다는 점이다.

TCP를 만든 당시 미국은 한창 냉전 시기였는데, 두번째 문제를 아주 큰 골치로 여겼다. 중계국이나 회선을 독점해야 하는 통신 방식은 전쟁에 있어 무척이나 취약한 형태였기 때문이다. 따라서 ==**데이터를 잘게 쪼개서 여러 곳으로 전송하는 방법을 연구하게 됐는데 이렇게 할 경우 한 중계소나 회선이 죽더라도 일부 데이터는 전달을 받을 수 있기 때문에 물리적 충격에 더 잘 대응 할 수있다.**==

![https://evan-moon.github.io/](https://evan-moon.github.io/static/200a4648f12fe0e8e32c2a9308df4465/0d98f/packets.png)

이러한 패킷 교환 방식의 통신이 제시된 후 패킷을 신뢰성있게 전달을 받고 싶은 욕구가 발생했고 이로 인해 TCP가 만들어지게 됐다.
____
### TCP의 특성
* **연결지향**
연결지향은 통신을 진행하는 ==두 대상이 논리적으로 만들어진 특정한 회선을 통해서만 통신을 주고받는 방식을 추구하는 것을 말한다.==
회선을 갖고 통신을 하는 이유는 신뢰성을 보장하기 위함인데 누가 어디까지 보냈고, 누구한테 어디서부터 보낼 것인지를 구분을 하려면 각 사용자가 구분이 돼야하기 때문이다. 

컨베이어 벨트를 통해 물건을 전달 받는 상황을 가정해보자. 컨베이어 벨트 별로 물건이 전달된다면 각 컨베이어 벨트 별 상태를 측정하고 이에 맞춰 대응하는 것이 가능하다. 하지만 컨베이어 벨트 없이 트럭에서 물건이 쏟아져서 전달된다면, 물건을 구분하는 것이 어려울 것이다. 만약 물건이 몇개 빠졌어도 어느 곳에 물건을 재요청할지도 파악할 수 없다.
==**세션을 통해 TCP는 상태를 확인하고 사용자를 식별할 수 있으며 이를 통해 신뢰성과 무결성을 위한 보장할 수 있다.**==
* **신뢰성**
**<u>신뢰성은 TCP의 목적이다</u>**. 신뢰성은 말 그대로 데이터가 온전히 송,수신됨을 신뢰할 수 있다는 것으로 TCP를 통해 데이터를 넘기거나 전달 받으면 해당 데이터는 손실 없이 송,수신됨 보장한다.
TCP에 존재하는 back-to-n, 윈도우 사이즈 조절, 연결 지향, 오프셋, 체크섬은 모두 이를 구현하기 위한 수단이다.

![](https://t1.daumcdn.net/thumb/R720x0/?fname=http://t1.daumcdn.net/brunch/service/user/4Ki1/image/LO5kA5nu5kR_9BiKjoLpADrZCi0.png)

> [!info]
> **TCP의 목적은 신뢰성 보장이고 이를 위해 연결을 식별할 필요가 존재한다. 따라서 가상의 회선을 통해 커넥션을 구분한다.**

___
### 3-Way Hand Shake
TCP 연결을 진행하기 위해 가장 우선적으로 처리해야 하는 작업은 연결을 수립하는 작업이다. 앞서 말했듯 TCP는 연결 지향이고 연결이 성사돼야 신뢰성을 보장할 수 있기 때문에 우선적으로 연결을 수립한다. 이때 ==**연결을 수립하는 과정을 3-Way Hand Shake라고 한다.**==

![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117142819.png)

클라이언트는 호스트로 연결 수립을 위한 SYN 패킷을 전송하고 호스트 또한 이를 수신한 응답인 SYN + ACK를 클라이언트에 돌려준다. 이후 클라이언트는 호스트에게 서버의 응답을 잘 받았다는 의미를 가진 ACK 패킷을 전달하고 이후 서버와 클라이언트 간의 TCP 통신이 시작된다.

* **CLOSED**
소켓이 생성 됐으나 아직 어떠한 연결도 받아들일 준비가 안돼있는 상태를 말한다. 소켓은 생성 직후 C해당 상태이다.
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117143127.png)
 
 * **LISTEN**
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117143317.png)
 * **SYN_SENT**
요청자가 수신자에게 연결 요청을 보낸다. 연결 요청을 할때 요청자는 수신자에게 시퀀스 번호를 생성해 SYN 패킷에 담아 전송한다. 이 SYN 패킷을 수신자가 수신하게 되면 소켓의 상태가 LISTEN->SYN_RECIEVED 변경된다.

* **SYN_RECIEVED**
수신자가  SYN 패킷을 전달 받은 경우를 의미하며 수신자는 이를 확인했다는 SYN-ACK 패킷을 요청자에게 다시금 돌려준다.이때 전송하는 승인 번호(ack_number)는 요청자가 전달한 시퀀스 번호 + 1이 된다. 실질적으로 데이터를 주고 받지는 않고 확인의 기능만 하면 되기 때문에 +1을 활용하는 것이다.
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117144006.png)

![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117144031.png)

* **ESTABLISHED**
**SYN-ACK 패킷이 요청자에게 전달되면 요청자는 자신의 소켓의 상태를 ESTABLISHED 변경**한다. **ESTABLISHED 두 소켓 간의 논리적인 회선이 이 단계에서 성립됐다고 해석하면 된다.**

클라이언트 소켓은 SYN-ACK를 수신하면 서버 소켓과의 연결을 생성한다. 클라이언트는 서버로 자신의 SYN-ACK에 대해 seq_number에 1을 더해 돌려준다. 요청자의 소켓은 이때 통신 가능한 상태로 변경된다.

수신자의 경우 요청자가 전달한 SYN-ACK에 대한 ACK를 수신하면 ESTABLISHED로 전환된다.
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117144734.png)
___
### 4-Way Hand Shake
TCP 연결을 종료하기 위해 사용하는 방법이다. 4-way handshake는 주요 과정으로 이를 잘못할 경우 <b><u>송,수신할 데이터가 남아있음에도 연결이 급하게 종료될 수 있고 이는 데드락을 발생시킬 수 있기 때문에 연결의 종료는 신중하게 이뤄져야 한다.</b></u>
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117211342.png)

- **FIN-WAIT-1** 
첫번째 FIN은 요청자로 부터 전송된다. 요청자가 연결의 종료를 주도하기 때문에 **능동 종료(Active Close)라고 불리기도 한다.**

* **CLOSE-WAIT**
수신자는 요청자로 부터 받은 FIN 패킷에 대한 응답을 전송한 후 CLOSE-WAIT 상태가 된다. <b><u>이후 수신자는 모든 처리를 완료하면 명시적으로 shutdown()이나 close() 함수 등을 호출해 다음 상태로 이동한다. 이때 수신자 내부에서 에러가 발생해 함수 호출이 이뤄지지 않으면 FIN 패킷을 요청자에게 전송하지 못할 경우 데드락이 발생할 수 있다. </u></b>
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117211847.png)
패킷이 위의 단계 까지만 교환되고 문제가 발생해 수신자에서 FIN 패킷을 다시 전송 못한다면, 송신자는 영영 FIN을 기다려야 한다.
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117212108.png)

- **LAST_ACK**
**수신자는 더 이상 처리할 데이터가 없을 경우 연결을 종료하는 함수(close)를 명시적으로 호출하고 요청자에게 FIN 패킷을 전송한다.** 이후 요청자로부터 FIN에 대한 응답이 올때 까지 대기한다. **만약 ACK가 오지 않으면 ACK만을 기다리며 계속해서 FIN을 전송할 수도 있다.**

* **FIN-WAIT-2**
 요청자는 수신자가 새로운 FIN 패킷을 보내주기까지 대기를 지속한다. 수신자의 상태가 CLOSE-WAIT에 머물면 요청자는 FIN-WAIT-2에 머물게 된다.
 
- **TIME-WAIT**
TIME-WAIT는 서버가 보낸 FIN 패킷을 수신하고 이에 응답하는 ACK 패킷을 전송한다. **==TIME-WAIT는 TCP 커넥션이 끊어질 때 필연적으로 발생하며 TIME OUT 기간 동안 무조건적으로 소켓을 열어 놓는 특징을 갖는다.**== 따라서 <b><u>서버로부터 FIN 패킷을 수신한 이후로도 한동안 소켓이 포트를 점유하고 있는 비효율을 유발하는데,</u></b> 여기에는 사연이 있다.
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117214139.png)

1. **전송이 완료 됐다고 생각했던 데이터가 네트워크 상에서 지연될 경우 유실된 데이터를 받지 못할 수 있다.**
2. **마지막 ACK가 유실될 경우 수신자는 LAST-ACK 상태에서 교착될 수있다.**
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117214830.png)

이에 따라 **인위적으로 TIME OUT 기간 동안 소켓을 열어놔 늦게 도착한 데이터 및 FIN의 수신과 ACK의 전송을 보장**한다. **TIME-WAIT 상태는 TIME OUT 기간을 넘어가면 자동적으로 종료**된다. (행온 상태가 아닐 경우)

**인위적으로 소켓을 열어놓기 떄문에 동일한 소켓을 재 사용하기 위해선 TIME-WAIT가 끝나는 시간까지 무조건 대기**해야한다. 소켓 프로그램을 재실행 했을 때 이 에러를 자주 봤을 것이다. 따라서 **TIME-WAIT가 동시 다발적으로 많이 발생할 경우 포트 부족 문제 등을 야기할 수 있기 때문에 소켓 설정을 변경할 필요가 존재한다.**
![](https://sunnnyimg.s3.ap-northeast-2.amazonaws.com/TCP%20%EA%B8%B0%EC%B4%88%20/%20Pasted%20image%2020231117214549.png)
___
### 4-Way 조금 더

- **왜 성립은 3인데 종료는 4일까?**
왜 종료를 할때 성립을 할 때 처럼 ACK와 FIN을 같이 한 패킷에 전송하면 안될까? 성립 할 때를 생각해보면, 서버는 보내야할 데이터가 존재하지 않고 버퍼 또한 비어 있다. 따라서 클라이언트에 ACK를 전송하는 것이 곧 전송을 시작해도 된다는 것을 의미한다.

반대로 종료를 생각해보면 ACK+FIN을 전송한다고 생각해보자. 이 경우 **서버가 종료할 준비가 됐다는 것을 파악할 수 없다. FIN에 대한 ACK를 전송할 때 서버가 종료 불가능한 상태일 수 있기 때문**이다. 따라서 **서버의 종료를 명확히 파악하기 위해서 서버가 FIN을 별도로 추가 전송한다.** TCP의 양방향 통신을 종료하기 위해 클라이언트의 연결을 종료하고 서버의 연결을 연달아 2단계에 거쳐 종료 한다고 생각해 볼 수 있다.

>[!info]
>**연결을 개시 할 땐 ACK를 전송할 때 이미 전송할 준비가 갖춰져 있지만, 종료의 경우 ACK를 전송할 때 종료할 준비가 안돼 있을 수 있다.**
