### 출처
* https://medium.com/@jamessoun93/ssh%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-87b58c521d6f (ssh란 + 깃헙 ssh)
* https://library.gabia.com/contents/9008 (ssh)
* https://sonsecurity.tistory.com/1 (텔넷과 ssh)
* https://tramamte.github.io/2018/07/25/rsa/ (RSA 원리)
* https://devocean.sk.com/blog/techBoardDetail.do?ID=163311 (깃 ssh)
___
### 개요
* [[#SSH란]]
* [[#SSH 메시지 포맷]]
* [[#대칭 키와 비대칭 키]]
* [[#대칭 키 VS 비대칭 키]]
* [[#SSH 통신 순서]]
* [[#RSA 찍먹]]
* [[#SSH 써먹어 보기 (+깃허브)]]
___
### SSH란

**SSH는 Secure Shell의 줄임말로 원격 호스트에 안전하게 접속하기 위해 사용하는 프로토콜**이다. 과거 원격 호스트 접속에는 텔넷을 사용했지만, **텔넷은 와이어 샤크 등의 툴을 활용해 패킷을 캡쳐 할 경우 오가는 데이터가 전부 보이는 보안 취약점이 존재**했다.

예를 들어 텔넷 서버에서 ls 명령어를 실행하고 싶어 클라이언트에서 ls 명령어를 입력 했다고 하자. 이때 전송되는 패킷을 열어보면 다음과 같다. ls 명령어를 실행한 것을 패킷에서 곧장 확인 할 수 있다.

![][https://t1.daumcdn.net/cfile/tistory/2532BA5055E54C812A]

반면 SSH로 접속해 동일한 작업을 반복할 경우 패킷 내용은 아래와 같이 보인다. 패킷 내용이 암호화 돼 보이지 않는 것을 확인 할 수 있다.

![][https://t1.daumcdn.net/cfile/tistory/24090E4D55E54AEB36]

이처럼 ==**SSH는 보안이 뛰어난 프로토콜이기에 현재는 텔넷을 대체해 원격 호스트 접속시 가장 많이 사용하는 프로토콜이 됐다.**==
___
### SSH 메시지 포맷

![[Pasted image 20231229174122.png]]

ssh는 패킷의 데이터를 압축해 자신에게 적절한 형태로 변환한 후 이를 암호화해 활용한다. 수신자는 암호화 된 데이터를 복호화 해 활용한다.
___
### 대칭 키와 비대칭 키

암호화를 위해선 키가 필요하다. 키는 암호를 생성하는 기준으로 암호문을 평문으로 변환하는데 사용하기도 한다. 키는 관리법에 따라 대칭 키와 비대칭 키로 분리되는데 해당 내용을 살펴보자.

#### 대칭 키

<b><u>대칭 키(symetirc key)는 암호화 할 때 사용하는 키와 복호화 할때 사용하는 키가 동일한 방식을 말한다.</u></b> 키가 없다면 해당 문서를 복호화 할 수 없다는 점에서 보안성이 뛰어나지만, 반대로 키만 탈취한다면 데이터를 모두 복호화 할 수 있다는 단점이 발생한다. 따라서 <b><u>대칭 키의 핵심은 키를 어떻게 안전하게 전달하지가 된다.</u></b>

![[Pasted image 20231229143613.png]]
#### 비대칭 키

**비대칭 키(asymetric key)는 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 동일하지 않은 방식을 말한다.** 이때 **두 가지의 키를 활용하는데 타인에게도 공개 돼 있는 공개 키(public key)와 자기 자신만 열람할 수 있는 개인 키(private key)이다.**

두 가지의 키중 어떠한 키를 통해 암호화를 진행하느냐에 따라 다른 용도로 키를 사용할 수 있다.

만약 공개 키를 통해 복호화를 하고 개인 키를 통해 암호화를 하는 방식을 사용한다고 생각해보자. <u><b>이 경우 사용자가 보낸 데이터를 공개 키를 통해 복호화 할 수 있으므로 누구나 사용자의 데이터를 확인할 수 있다. </b></u>이 경우 **데이터의 내용 보다는 데이터가 누구로 부터 전송됐는지를 명확히 확인하기 위해 사용하는 방식**이다. 어떠한 데이터를 갖던 특정 인물의 공개 키를 통해 복호화가 된다면 해당 인물이 전송한 데이터라는 것을 확신할 수 있다. 따라서 **이와 같은 방법은 전자서명 등의 분야에서 사용**된다.

반대로 공**개키를 통해 암호화를 하고 개인키를 통해 복호화를 할 경우 개인키를 소유한 개인만 내용물 확인이 가능 하므로 전자서명에는 활용 불가**하다. 하지만 **==메시지가 누출 되더라도 키를 가지고 있는 개인만 복호화가 가능하기에 안전한 통신이 가능하다.==**

![[Pasted image 20231229144049.png]]

#### 대칭 키 VS 비대칭 키

대칭 키는 전송을 진행할 때 마다 필요하게 된다. 예를 들어 N명이 존재하는 네트워크에서 구성원 모두가 서로에게 데이터를 전송할 수 있게 되기 위해서는 각 구성원이 생성할 수 있는 모든 전송에 대한 키를 가져야 하므로 N * (N - 1)개의 키를 가지게 된다. 이때 대칭키를 사용함으로 암호화 복호화에 동일한 키가 사용된다. **따라서 총 필요한 키의 수는 N(N-1)/2가 된다.**

비대칭 키의 경우를 생각해보면 공개 키가 N개 각 인원마다 존재하고 개인 키가 또 다시 N개 존재해 총 2N개의 키가 존재하게 된다. 따라서 **대칭 키 방식에 비해 관리해야할 키의 수가 월등히 적다.**

**==비대칭 키의 경우 대칭 키 보다 키의 길이가 길며 복잡한 수학 연산을 자주 활용해 암호화나 복호화 과정에 시간이 오래 소요된다.==** 하지만, 확장성이 뛰어나고 키 관리가 용이하다는 장점이 존재한다.
___
### SSH 통신 순서

SSH는 비대칭 키 방식과 대칭 키 방식을 적절히 혼합해 통신을 진행한다. 앞서 말했듯 **비대칭 키를 활용한 암, 복호화 알고리즘은 대칭 키에 비해 오버헤드가 크기 때문에 비대칭 키 방식을 활용해 대칭 키를 교환하고 이후 대칭 키를 통해 통신을 진행**한다. (잠금,해금으로 열쇠가 2개 존재하는 자물쇠는 아무래도 키가 단일한 자물쇠보다 복잡할 수 밖에 없다)

자세한 동작 순서는 아래와 같다. 호스트 1과 2가 통신을 진행한다 해보자.

1. 호스트 1이 공개, 비공개 키 쌍을 생성한다. 
2. 자신의 공개 키를 사용자 모두가 접근 할 수 있는 곳으로 전송한다.
3. 호스트 2는 호스트 1의 공개 키를 활용해 랜덤한 문자열을 암호화 해 전송한다.
4. 호스트 1은 비공개 키를 활용해 호스트 2가 전달한 문자열을 복호화 하고 호스트 2에 전송한다.
5. 호스트 2는 호스트 1이 자신이 전달한 값과 비교해 일치 할 경우 대칭 키를 생성한다.
6. 이후 **생성한 대칭 키를 호스트 1의 공개키로 암호화 해 전달**한다.
7. 호스트 1은 대칭키를 자신의 비공개 키로 복호화 한다.
8. 이후 호스트 1은 대칭 키로 데이터를 암호화 해 호스트 2와 통신한다.

![[Pasted image 20231229174528.png]]
___
### RSA 찍먹

RSA는 빈번히 사용되는 대칭 키 알고리즘으로 RSA2048, 4096 등 여러 버전으로 존재한다. AWS, FCM 등에서 발급해주는 .pem 파일이 전부 이 알고리즘을 활용해 만들어진다.

RSA는 큰 수의 소인수 분해는 많은 시간이 소요된 다는 점을 활용해 보안성을 높인 방식이다. RSA를 브루트포스로 공략하는 것은 실질적으로 불가능하며 **연산량이 제법 크기 때문에 복호화 자체에도 오버헤드가 큰 편이다.** (대칭키 알고리즘 AES에 비해 100배 느리다.)

이제 RSA에서 암호화 및 복호화를 하는 방법을 살펴보자. RSA는 다음과 같이 동작한다.

1. 서로 다른 소수 $p, q$를 고른다.
2. $(p−1),(q−1)$과 각각 서로소인 $e$를 고른다.
3. $(p−1)(q−1)$로 나눴을 때 나머지가 1이 되는 $ed$를 찾는다.
4. $N=pq$를 구한다.
5. $N=pq$ 를 계산하고 $N,e$ 를 공개키로 사용한다. 한편 $d$ 는 공개되지 않고 복호화를 위한 개인키로 활용된다.
6. 전송하고자 하는 메시지 $m$이 존재할 때 암호화는 다음과 같이 진행한다. $$ c={m}^{{e}} \bmod {N}$$
8. 복호화를 하는 방법은 다음과 같다. $$ m=c^d \bmod N $$
공개 키 정보만으로 복호화를 시도하려면 주어진 $N$값을 통해 $d$를 유추해야 한다. d를 구하기 위해선 식을 다음과 같이 정리할 수 있다. $ed = k(p-1)(q-1)+1$

이때 e는 공개돼 있으므로 p,q 값을 유추 하려면 $N=pq$를 통해 값을 찾아야 한다. $N$은 두 소수의 곱으로 구성돼 있으므로 소인수 분해 연산을 진행해 값을 구해야 하는데, $N$의 값이 엄청나게 큰 숫자로 설정돼 소인수 분해를 거의 불가능하게 만든다.

> [!info]
> RSA의 핵심 보안원리는 큰 수의 소인수 분해는 어렵다는 점이다.

___
### SSH 써먹어 보기 (+깃허브)

깃허브 인증을 SSH를 활용해 처리할 수 있다. 토큰을 활용할 필요 없이 SSH를 활용해 곧장 깃허브 인증을 진행해보자.

#### RSA키 만들기

```bash
ls -al ~/.ssh //pem 파일 저장 폴더로 이동한다.
```

```bash
ssh-keygen -t rsa -b 4096 -C "your_git_email@example.com" //rsa키 생성
```

![[스크린샷 2023-12-29 오후 5.17.25.png]]

id_rsa라는 RSA 키가 생성된 것을 확인 할 수가 있다. 이제 이걸 깃에 등록해주면 된다.

#### 깃에 등록하기

![[스크린샷 2023-12-29 오후 5.18.50.png]]
해당 메뉴로 이동한다.

![[스크린샷 2023-12-29 오후 5.19.40.png]]
새로운 키를 등록해준다. 이때 깃에는 공개키를 등록해줘야 한다.

![[스크린샷 2023-12-29 오후 5.20.07.png]]
이렇게 키가 등록되면 성공이다.

### 접속 테스트

공개 키를 깃에 등록 했으니 이제 SSH 접속이 잘되는지 테스트 해보자.
테스트는 아래 코드로 진행 가능하다.

```bash
ssh -T git@github.com //내 깃허브 메일

> The authenticity of host 'github.com (IP ADDRESS)' can't be established.
> RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
> Are you sure you want to continue connecting (yes/no)? yes <-- 입력하고 엔터 

Hi thinkJin99! You've successfully authenticated, but GitHub does not provide shell access. //메시지 출력되면 성공!
```

이제 부터 HTTPS가 아닌 SSH 방식을 활용해 Clone이나 Push 등을 진행할 수 있다. remote 주소를 HTTPS 형태가 아닌 SSH 형태에 맞게 입력하면 자동으로 SSH 푸시가 가능해진다.

> [!info]
> **SSH를 활용하면 토큰 관리의 번거로움 부터 해방이 가능하다. RSA 인증서는 만료 기한도 없다**
